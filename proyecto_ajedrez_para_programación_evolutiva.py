# %% [markdown]
# -*- coding: utf-8 -*-
"""Proyecto AJEDREZ para Programación Evolutiva.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18FSqh6mQ1w8OWcZVCyKK4fizPVPKGV0G

#Proyecto AJEDREZ para Programación Evolutiva.ipynb
Alumnos:
"""
# %% 
# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import random
import copy
import time
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
# %matplotlib inline
# %% [markdown]
"""
imports de archivos
"""
# %%
from middle_game import get_fitness_individual, get_best_move, get_df_fun_eval_partida
from leer_cotas_del_csv import cotas_inferiores,cotas_superiores


# %%
##########################PARAMETROS##########################
##semillas
random.seed(13)
np.random.seed(13)
##llamamos a los juegos de la database(mas especificamente las partidas a evaluar)
df_games = pd.read_csv('../Utils/Data/resumen_jugadas.csv', ',', index_col=0)
##llamamos al dataframe que contiene todas las posibles jugadas y sus parametros
df_fun_eval = pd.read_csv('../Utils/Data/jugadas_fun_eval.csv', ',', index_col=0)
##numero de juegos a tomar en la base de datos (valores entre 0 y 1074)
jugadas_evaluadas = 1074
##parametros para el algoritmo evolutivo
###parametros poblacion
n_individuos = 100
n_de_variables = 33
limite_inferior = cotas_inferiores
limite_superior = cotas_superiores
###parametros optimizacion
optimizacion = "max"
n_generaciones = 70
tipo_seleccion = "ruleta"
metodo_cruce = 'cruce_uniforme'
p_sobrevivientes = 0.3
probabilidad_mutacion = 0.1
parada_temprana = True
rondas_parada = 50
tolerancia_parada = 10**-3
verbose = True
verbose_evaluacion = True
##############################################################################
# %% [markdown]
""" para registrar el output """
def log_print(output):
  print(output)
  with open("../log.txt","a") as f:
    f.write("{}\n".format(output))    
# %% [markdown]
"""#Definimos fenotipo y genotipo"""
# %%
def decodificacion(cromosoma):  
  return cromosoma

def crear_cromosoma(n_de_variables, limite_inferior, limite_superior):

  valor_variables = np.repeat(None, n_de_variables)

  for i in np.arange(n_de_variables):
        # Para cada variable, se genera un valor aleatorio dentro del rango
        # permitido para esa variable.
            valor_variables[i] = random.randint(
                                        limite_inferior[i],
                                        limite_superior[i]
                                      )  
  
  return valor_variables

# %% [markdown]
"""#Defino mi funcón Objetivo"""
# %%
def funcion_objetivo(individual):  
  total_score = 0        
  for id_partida in range(jugadas_evaluadas):            
      best_move = get_best_move(df_games, id_partida)    
      df_fun_eval_turn = get_df_fun_eval_partida(df_fun_eval, id_partida)
      one_ply_score = get_fitness_individual(df_fun_eval_turn, best_move, individual)
      total_score += one_ply_score

  return total_score
# %% [markdown]
"""#Clase Individuo
con metodos:

1.   calcular_puntaje()
2.   mutar()

"""
# %%
class Individuo:  

  def __init__(self,n_de_variables, limite_inferior,limite_superior):
    self.cromosoma = crear_cromosoma(n_de_variables,limite_inferior,limite_superior)
    self.fenotipo = decodificacion(self.cromosoma)
    self.n_de_variables = n_de_variables
    self.limites_inf = limite_inferior
    self.limites_sup = limite_superior
    self.puntaje_real = None
    self.puntaje_fitness = None
    self.probabilidad = None

  def calcular_puntaje(self,funcion_objetivo,optimizacion):
    self.puntaje_real = funcion_objetivo(self.fenotipo)
    if optimizacion == "max":      
      self.puntaje_fitness = self.puntaje_real
      if self.puntaje_real < 0:
        self.puntaje_fitness = 0
    if optimizacion == "min":
      self.puntaje_fitness = -self.puntaje_real


  def mutar(self, prob_mut=0.01, distribucion="uniforme", media_distribucion=1,
            sd_distribucion=1, min_distribucion=-1, max_distribucion=1,
            verbose=False):
      """
      Este método somete al individuo a un proceso de mutación en el que, cada
      una de sus posiciones, puede verse modificada con una probabilidad 
      `prob_mut`. Tras mutar, los atributos `valor_funcion` y `fitness` se
      reinician.
      
      Parameters
      ----------
      prob_mut : `float`, optional
          probabilidad que tiene cada posición del individuo de mutar.
          (default 0.01)

      distribucion : {"normal", "uniforme", "aleatoria"}, optional
          distribución de la que obtener el factor de mutación.
          (default "uniforme")

      media_distribucion : `float`, optional
          media de la distribución si se selecciona `distribucion = "normal"`
          (default 1)

      sd_distribucion : `float`, optional
          desviación estándar de la distribución si se selecciona
          `distribucion = "normal"`. (default 1)

      min_distribucion : `float`, optional
          mínimo de la distribución si se selecciona 
          `distribucion = "uniforme"`. (default -1)

      max_distribucion : `float`, optional
          máximo de la distribución si se selecciona 
          `distribucion = "uniforme"`. (default +1)
      
      verbose : `bool`, optional
          mostrar información del proceso por pantalla. (default ``False``)

      Raises
      ------
      raise Exception
          si el argumento `distribucion` es distinto de 'normal', 'uniforme' o
          'aleatoria'.

      Examples
      --------
      Ejemplo mutar individuo.

      >>> individuo = Individuo(
                      n_variables = 3,
                      limites_inf = [-1,2,0],
                      limites_sup = [4,10,20],
                      verbose     = True
                  )

      >>> individuo.mutar(
              prob_mut         = 0.5,
              distribucion     = "uniforme",
              min_distribucion = -1,
              max_distribucion = 1,
              verbose          = True
          )

      Notes
      -----

      El proceso de mutación añade diversidad al proceso y evitar que el
      algoritmo caiga en mínimos locales por que todos los individuos sean
      demasiado parecidos de una generación a otra. Existen diferentes
      estrategias para controlar la magnitud del cambio que puede provocar una
      mutación.

      - Distribución uniforme: la mutación de la posición i se consigue
      sumándole al valor de i un valor extraído de una distribución uniforme,
      por ejemplo una entre [-1,+1].

      - Distribución normal: la mutación de la posición i se consigue sumándole
        al valor de i un valor extraído de una distribución normal, comúnmente
        centrada en 0 y con una determinada desviación estándar. Cuanto mayor
        la desviación estándar, con mayor probabilidad la mutación introducirá
        cambios grandes.

      - Aleatorio: la mutación de la posición i se consigue reemplazando el
      valor de i por nuevo valor aleatorio dentro del rango permitido para esa
      variable. Esta estrategia suele conllevar mayores variaciones que las dos
      anteriores.

      Hay que tener en cuenta que, debido a las mutaciones, un valor que
      inicialmente estaba dentro del rango permitido puede salirse de él.
      Una forma de evitarlo es: si el valor tras la mutación excede alguno de
      los límites acotados, se sobrescribe con el valor del límite. Es decir,
      se permite que los valores se alejen como máximo hasta el límite impuesto.

      """

      # COMPROBACIONES INICIALES: EXCEPTIONS Y WARNINGS
      # ----------------------------------------------------------------------
      if not distribucion in ["normal", "uniforme", "aleatoria"]:
          raise Exception(
              "El argumento distribucion debe ser: 'normal', 'uniforme' o " \
              + "'aleatoria'"
              )

      # SELECCIÓN PROBABILISTA DE POSICIONES (VARIABLES) QUE MUTAN
      #-----------------------------------------------------------------------
      posiciones_mutadas = np.random.uniform(
                              low=0,
                              high=1,
                              size=self.n_de_variables
                            )
      posiciones_mutadas = posiciones_mutadas > prob_mut

      # MODIFICACIÓN DE LOS VALORES DE LAS VARIABLES SELECCIONADAS
      #-----------------------------------------------------------------------
      # Si la distribución seleccionada es "uniforme" o "normal", se extrae un
      # valor aleatorio de la distribución elegida que se suma para modificar
      # la/las posiciones mutadas.

      if distribucion in ["normal", "uniforme"]:
          if distribucion == "normal":
              factor_mut = np.random.normal(
                              loc   = media_distribucion,
                              scale = sd_distribucion,
                              size  = np.sum(posiciones_mutadas)
                            )
          if distribucion == "uniforme":
              factor_mut = np.random.uniform(
                              low  = min_distribucion,
                              high = max_distribucion,
                              size = np.sum(posiciones_mutadas)
                            )
          self.fenotipo[posiciones_mutadas] = \
              self.fenotipo[posiciones_mutadas] + factor_mut

          # Se comprueba si algún valor mutado supera los límites impuestos.
          # En tal caso se sobrescribe con el valor del límite correspondiente.
          for i in np.flatnonzero(posiciones_mutadas):
              if self.fenotipo[i] < self.limites_inf[i]:
                  self.fenotipo[i] = self.limites_inf[i]
              if self.fenotipo[i] > self.limites_sup[i]:
                  self.fenotipo[i] = self.limites_sup[i]

      # Si la distribución seleccionada es "aleatoria", se sobreescribe el
      # valor de la variable con un nuevo valor aleatorio dentro de los 
      # límites establecidos.
      if distribucion == "aleatoria":
          for i in np.flatnonzero(posiciones_mutadas):
              self.fenotipo[i] = random.uniform(
                                          self.limites_inf[i],
                                          self.limites_sup[i]
                                        )
      # REINICIO DEL VALOR Y DEL FITNESS
      #-----------------------------------------------------------------------
      # Dado que el individuo ha mutado, el valor de su fitness y de la
      # función objetivo ya no son validos.
      self.fitness = None
      self.valor_funcion = None

      # INFORMACIÓN DEL PROCESO (VERBOSE)
      # ----------------------------------------------------------------------
      if verbose:
          log_print("El individuo ha sido mutado")
          log_print("---------------------------")
          log_print("Total mutaciones: " + str(np.sum(posiciones_mutadas)))
          log_print("Valor variables: " + str(self.fenotipo))
          log_print("")
# %% [markdown]
"""#Clase Poblacion
con metodos:

1.   evaluar_poblacion()
2.   seleccion()
3.   cruce()
4.   nueva_generacion()
5.   optimizar()
"""
# %% 
class Poblacion:

  def __init__(self,n_individuos,n_de_variables, limite_inferior,limite_superior):
    
    self.n_individuos = n_individuos
    # Lista de los individuos de la población
    self.individuos = []
    # Mejor individuo de la población
    self.mejor_individuo = None
    self.mejor_individuo_indice = None
    # Límite inferior de cada variable
    self.limite_inferior = limite_inferior
    # Límite superior de cada variable
    self.limite_superior = limite_superior    
    # Etiqueta para saber si la población ha sido optimizada
    self.optimizado = False
    # Número de iteraciones de optimización llevadas a cabo
    self.iter_optimizacion = None    
    # Fitness del mejor individuo de la población (el de mayor fitness)
    self.mejor_fitness = None
    # Valor de la función objetivo del mejor individuo de la población
    self.mejor_puntaje_real = None
    # Valor de las variables del mejor individuo de la población
    self.mejor_cromosoma = None
    # Información de todas los individuos de la población en cada generación
    self.historico_individuos = []
    # Valor de las variables del mejor individuo en cada generación
    self.historico_mejor_cromosoma = []
    # Fitness del mejor individuo en cada generación
    self.historico_mejor_fitness = []
    # Valor de la función objetivo del mejor individuo en cada generación
    self.historico_mejor_puntaje_real = []
    # Diferencia absoluta entre el mejor fitness de generaciones consecutivas
    self.diferencia_abs = []
    # data.frame con la información del mejor fitness y valor de variables
    # encontrado en cada generación, así como la diferencia respecto a la 
    # generación anterior.
    self.resultados_df = None
    # Fitness del mejor individuo de todas las generaciones
    self.fitness_optimo = None
    # Valor de las variables del mejor individuo de todas las generaciones
    self.cromosoma_optimo = None
    # Valor de función objetivo del mejor individuo de todas las generaciones
    self.puntaje_real_optimo = None
    # VALOR PROMEDIO DE PADRES ESCOGIDOS
    self.promedio_padres = None
    # VALOR PROMEDIO DE TODOS
    self.promedio_individuos = None
    # DESVIACION ESTANADAR
    self.desviacion_standar = None
    # HISTORICO PRESION DE SELECCION
    self.presion_de_seleccion = []
  #########################################

    for i in np.arange(self.n_individuos):
      self.individuos.append(Individuo(n_de_variables,limite_inferior,limite_superior))
  
  def evaluar_poblacion(self,funcion_objetivo,optimizacion,verbose = False):
           
      promedio = 0
      for i in np.arange(self.n_individuos):
        #evaluar a la poblacion
        self.individuos[i].calcular_puntaje(funcion_objetivo,optimizacion)        
        #CALCULAR PROMEDIO DE TODOS LOS INDIVIDUOS
        #log_print("n_individuo "+str(self.n_individuos))
        #log_print("individuo "+str(i)+": puntaje real: "+str(self.individuos[i].puntaje_real))
        promedio += self.individuos[i].puntaje_real/self.n_individuos
      

      #seleccionar al mejor individuo      
      self.mejor_individuo = copy.deepcopy(self.individuos[0])
      self.mejor_individuo_indice = 0
      for i in np.arange(self.n_individuos):
        if self.individuos[i].puntaje_fitness > self.mejor_individuo.puntaje_fitness:
          self.mejor_individuo = copy.deepcopy(self.individuos[i]) 
          self.mejor_individuo_indice = i   
      

      # Se extrae la información del mejor individuo de la población.
      self.mejor_fitness = self.mejor_individuo.puntaje_fitness
      self.mejor_cromosoma = self.mejor_individuo.cromosoma
      self.mejor_puntaje_real = funcion_objetivo(self.mejor_individuo.cromosoma)
      # SE AÑADE INFORMACION SOBRE EL PROMEDIO
      self.promedio_individuos = promedio
      # Se imprime dicha información
      puntajes = [self.individuos[i].puntaje_fitness for i in np.arange(self.n_individuos)]
      """log_print("=========================")
      log_print("SUMA DE FITNESS = "+str(np.sum(puntajes)))"""
      log_print("=========================")
      log_print("PROMEDIO DE INDIVIDUOS = "+str(self.promedio_individuos))
      log_print("=========================")
      

  
  def seleccion(self,n_selecciones,tipo = "ruleta",n_hojas_torneo = 4):    
    array_puntajes = np.repeat(None,self.n_individuos)
    #log_print("array_puntajes.size = ",array_puntajes.size)
    #log_print("n_individuos.size = ",self.n_individuos)
    for i in np.arange(self.n_individuos):
      #log_print("individuo["i"] puntaje = ",self.individuos[i].puntaje_fitness)
      array_puntajes[i] = copy.copy(self.individuos[i].puntaje_fitness)    
    
    if tipo == "ruleta":
      probabilidad = array_puntajes / np.sum(array_puntajes)    
     # log_print("PROBABILIDAD: "+str(probabilidad))

      ############MODIFICAR ESTO, MEJORAR log_printEO DE PROBABILIDADIDES###################
      self.mejor_individuo.probabilidad = 0
      for i in np.arange(self.n_individuos):            
        self.individuos[i].probabilidad = probabilidad[i]
        if self.individuos[i].probabilidad > self.mejor_individuo.probabilidad:
            self.mejor_individuo.probabilidad = self.individuos[i].probabilidad
        #log_print("individuo ("+str(i)+") probabilidad: "+str(self.individuos[i].probabilidad))
      ############MODIFICAR ESTO, MEJORAR log_printEO DE PROBABILIDADIDES###################

      indices_seleccionados = np.random.choice(
                                              a = np.arange(self.n_individuos),
                                              size = n_selecciones,
                                              replace = True,
                                              p = probabilidad.tolist()
                                              )     

    elif tipo == "torneo":
      indices_seleccionados = np.repeat(None,n_selecciones)
      for i in np.arange(n_selecciones):       
        
        # Método general            
        candidatos =  np.random.choice(
                          a       = np.arange(self.n_individuos),
                          size    = n_hojas_torneo,
                          replace = False
                        )
        
        fitneses_candidatos = np.repeat(None,n_hojas_torneo)
        for n in np.arange(n_hojas_torneo):
          fitneses_candidatos[n] = copy.copy(self.individuos[candidatos[n]].puntaje_fitness)
        #log_print("candidatos_fitneses=" +str(fitneses_candidatos))
        ind_final = candidatos[np.argmax(fitneses_candidatos)]
        indices_seleccionados[i] = ind_final  
        #log_print("ind_final="+str(ind_final))
        #log_print("candidatos"+str(candidatos))  

      
    return indices_seleccionados


  def cruce(self,padre_1,padre_2,metodo_de_cruce='default'):
    
    
    #METODO DE CRUCE MITAD Y MITAD
    if metodo_de_cruce == 'default':
      descendencia = copy.deepcopy(self.individuos[padre_1])
      descendencia.fenotipo = None
      descendencia.puntaje_real = None
      descendencia.puntaje_fitness = None
      descendencia.probabilidad = None   
      for i in np.arange(int(descendencia.cromosoma.size/2)):
        descendencia.cromosoma[i] = copy.deepcopy(self.individuos[padre_2].cromosoma[i])

      descendencia = copy.deepcopy(descendencia)
      descendencia.fenotipo = decodificacion(descendencia.cromosoma)

    #METODO DE CRUCE UNIFORME
    if metodo_de_cruce == 'cruce_uniforme':
      descendencia = copy.deepcopy(self.individuos[padre_2])
      descendencia.fenotipo = None
      descendencia.puntaje_real = None
      descendencia.puntaje_fitness = None
      descendencia.probabilidad = None   

      mascara = np.random.randint(0,2,size = int(descendencia.cromosoma.size))

      for i in np.arange(int(descendencia.cromosoma.size)):
        if mascara[i]:
          descendencia.cromosoma[i] = copy.deepcopy(self.individuos[padre_1].cromosoma[i])
      
      descendencia = copy.deepcopy(descendencia)
      descendencia.fenotipo = decodificacion(descendencia.cromosoma)

    return descendencia 

  def nueva_generacion(self,p_sobrevivientes,probabilidad_mutacion,tipo_seleccion = "ruleta",metodo_de_cruce = 'default',
                      distribucion="uniforme",
                      min_distribucion=-1, max_distribucion=1,
                      verbose_mutacion=False):
    nuevos_individuos = []
    
    #seleccionamos sobrevivientes
    n_sobrevivientes = int(np.ceil(self.n_individuos*p_sobrevivientes))
    # Se identifican los n_sobrevivientes individuos con mayor fitness.
    array_puntaje = np.repeat(None, self.n_individuos)
    for i in np.arange(self.n_individuos):
        array_puntaje[i] = copy.copy(self.individuos[i].puntaje_fitness)
    rank = np.flip(np.argsort(array_puntaje))
    sobrevivientes = [copy.deepcopy(self.individuos[i]) for i in rank[:n_sobrevivientes]]
    # Se añaden los sobrevivientes a la lista de nuevos individuos.
    nuevos_individuos = nuevos_individuos + sobrevivientes

    #creamos promedio_seleccionados para sacar promedio de padres
    promedio_seleccionados = 0
    #creamos nuevos individuos mediante curces
    for i in np.arange(self.n_individuos-n_sobrevivientes):
      #seleccionamos a los padres
      indices_padres = self.seleccion(n_selecciones = 2,tipo=tipo_seleccion)
      #creamos la descendencia
      descendencia = self.cruce(indices_padres[0],indices_padres[1],metodo_de_cruce=metodo_de_cruce)
      #mutamos a la descendencia
      p_mutacion = np.random.choice(
                                    a = [True,False],
                                    replace = True,
                                    p = (probabilidad_mutacion,1-probabilidad_mutacion)
                                   )
      #calculamos promedio_seleccionados
      promedio_seleccionados += (self.individuos[indices_padres[0]].puntaje_real + self.individuos[indices_padres[1]].puntaje_real)/(2*(self.n_individuos-n_sobrevivientes))
      if p_mutacion:
        descendencia.mutar(
                prob_mut         = probabilidad_mutacion,
                distribucion     = distribucion,
                min_distribucion = min_distribucion,
                max_distribucion = max_distribucion,
                verbose          = verbose_mutacion
            )
      #añadimos a los descendientes mutados
      nuevos_individuos = nuevos_individuos + [descendencia]

    self.promedio_padres = promedio_seleccionados 
    log_print("=========================")
    log_print("PROMEDIO_SELECCIONADOS = "+str(promedio_seleccionados))
    log_print("=========================")
    if self.desviacion_standar == 0:
      log_print("PRESION DE SELECCION = TODOS LOS INDIVIDUOS TIENEN IGUAL FITNESS")
    else:
      self.presion_de_seleccion.append(   
                                      (self.promedio_padres-self.promedio_individuos)/self.desviacion_standar  
                                      )   
      log_print("PRESION DE SELECCION = "+str(self.presion_de_seleccion[-1]) )
    #actualizamos valores de la poblacion    
    self.individuos = copy.deepcopy(nuevos_individuos)
    self.mejor_individuo = None

  def optimizar(self,funcion_objetivo,optimizacion,n_generaciones = 50,tipo_seleccion = 'ruleta',metodo_cruce = 'default',
                p_sobrevivientes = 0.1,probabilidad_mutacion = 0.01,
                parada_temprana = True,rondas_parada = 10,
                tolerancia_parada = 10**0,verbose = False,verbose_evaluacion = False,                
                distribucion="uniforme",
                min_distribucion=-1, 
                max_distribucion=1,
                verbose_mutacion=False):
    
    start = time.time()

    for i in np.arange(n_generaciones):
      if verbose:
          log_print("=============")
          log_print("Generación: " + str(i))
          log_print("=============")
      
      # EVALUAR INDIVIDUOS DE LA POBLACIÓN
      # ------------------------------------------------------------------
      self.evaluar_poblacion(
                            funcion_objetivo = funcion_objetivo,
                            optimizacion     = optimizacion,
                            verbose          = verbose_evaluacion
                            )
      DUMMY = self.seleccion(1,tipo_seleccion)
      
      # CALCULAR LA DESVIACION ESTANDAR ------------------------------------------------------------------
      array_puntajes = np.repeat(None,self.n_individuos)
      for k in np.arange(self.n_individuos):
        #log_print("individuo["k"] puntaje = ",self.individuos[k].puntaje_fitness)
        array_puntajes[k] = copy.copy(self.individuos[k].puntaje_real)    
      #CALCULAMOS LA DESVIACION ESTANDAR
      self.desviacion_standar = np.std(array_puntajes)
      log_print("DESVIACIÓN ESTANDAR: "+str(self.desviacion_standar))
      log_print("=========================")

      # MOSTRAR POBLACION
      # ------------------------------------------------------------------
      for individuo in np.arange(self.n_individuos):
        log_print("Individuo ("+str(individuo)+"): ")
        log_print("           +cromosoma: " + str(self.individuos[individuo].cromosoma))
        #log_print("           +fenotipo: " + str(self.individuos[individuo].fenotipo))
        log_print("           +puntaje real: " + str(self.individuos[individuo].puntaje_real))
        #log_print("           +puntaje fitness: " + str(self.individuos[individuo].puntaje_fitness))
        #if tipo_seleccion == "ruleta": log_print("           +probabilidad: " + str(self.individuos[individuo].probabilidad))
        log_print("-------------------------------------------")
      log_print("Mejor Individuo: Individuo ("+str(self.mejor_individuo_indice)+")")
      log_print("           +cromosoma: " + str(self.mejor_individuo.cromosoma))
      #log_print("           +fenotipo: " + str(self.mejor_individuo.fenotipo))
      log_print("           +puntaje real: " + str(self.mejor_individuo.puntaje_real))
      #log_print("           +puntaje fitness: " + str(self.mejor_individuo.puntaje_fitness))
      #if tipo_seleccion == "ruleta": log_print("           +probabilidad: " + str(self.mejor_individuo.probabilidad))
      log_print("-------------------------------------------")

      # SE ALMACENA LA INFORMACIÓN DE LA GENERACIÓN EN LOS HISTÓRICOS
      # ------------------------------------------------------------------
      self.historico_individuos.append(copy.deepcopy(self.individuos))
      self.historico_mejor_fitness.append(copy.deepcopy(self.mejor_fitness))
      self.historico_mejor_cromosoma.append(copy.deepcopy(self.mejor_cromosoma))
      self.historico_mejor_puntaje_real.append(copy.deepcopy(self.mejor_puntaje_real))      

      # SE CALCULA LA DIFERENCIA ABSOLUTA RESPECTO A LA GENERACIÓN ANTERIOR
      # ------------------------------------------------------------------
      # La diferencia solo puede calcularse a partir de la segunda
      # generación.
      if i == 0:
        self.diferencia_abs.append(None)      
      else:        
        diferencia = abs(self.historico_mejor_fitness[i] - self.historico_mejor_fitness[i-1])
        self.diferencia_abs.append(diferencia)
        log_print(">Diferencia con el mejor puntaje de la anterior generación: " + str(diferencia)+"\n")  


      # CREAR UNA NUEVA GENERACIÓN
      # ------------------------------------------------------------------    
      self.nueva_generacion(
                            p_sobrevivientes = p_sobrevivientes,
                            probabilidad_mutacion = probabilidad_mutacion,
                            tipo_seleccion = tipo_seleccion,
                            metodo_de_cruce = metodo_cruce,
                            distribucion = distribucion,
                            min_distribucion = min_distribucion, 
                            max_distribucion = max_distribucion,
                            verbose_mutacion = verbose_mutacion
                           )

      # CRITERIO DE PARADA
      # ------------------------------------------------------------------
      # Si durante las últimas n generaciones, la diferencia absoluta entre
      # mejores individuos no es superior al valor de tolerancia_parada,
      # se detiene el algoritmo y no se crean nuevas generaciones.
      if parada_temprana and i > rondas_parada:
          ultimos_n = np.array(self.diferencia_abs[-(rondas_parada):])
          if all(ultimos_n < tolerancia_parada):
              log_print("Algoritmo detenido en la generación " 
                    + str(i) \
                    + " por falta cambio absoluto mínimo de " \
                    + str(tolerancia_parada) \
                    + " durante " \
                    + str(rondas_parada) \
                    + " generaciones consecutivas.")
              break


    end = time.time()
    self.optimizado = True
    self.iter_optimizacion = i
    
    # IDENTIFICACIÓN DEL MEJOR INDIVIDUO DE TODO EL PROCESO
    # ----------------------------------------------------------------------
    indice_valor_optimo  = np.argmax(np.array(self.historico_mejor_fitness))
    self.fitness_optimo  = self.historico_mejor_fitness[indice_valor_optimo]
    self.puntaje_real_optimo = self\
                                .historico_mejor_puntaje_real[indice_valor_optimo]
    self.cromosoma_optimo = self\
                                  .historico_mejor_cromosoma[indice_valor_optimo]
    
    # CREACIÓN DE UN DATAFRAME CON LOS RESULTADOS
    # ----------------------------------------------------------------------
    self.resultados_df = pd.DataFrame(
        {
        "mejor_fitness"        : self.historico_mejor_fitness,
        "mejor_puntaje_real"  : self.historico_mejor_fitness,
        "mejor_cromosoma": self.historico_mejor_cromosoma,
        "diferencia_abs"       : self.diferencia_abs
        }
    )
    self.resultados_df["generacion"] = self.resultados_df.index
    log_print("-------------------------------------------")
    log_print("Optimización finalizada ")
    log_print("-------------------------------------------")
    log_print("Duración optimización: " + str(end - start))
    log_print("Número de generaciones: " + str(self.iter_optimizacion))
    log_print("Valor óptimo de las variables: " + str(self.cromosoma_optimo))
    log_print("Valor función objetivo: " + str(self.puntaje_real_optimo))
    log_print("")

# %% [markdown]
"""#Resultados mediante metodo de seleccion ruleta"""
# %%
poblacion = Poblacion(
                n_individuos = n_individuos,
                n_de_variables = n_de_variables,
                limite_inferior = cotas_inferiores,
                limite_superior = cotas_superiores
            )

poblacion.optimizar(funcion_objetivo = funcion_objetivo,
                    optimizacion = optimizacion,
                    n_generaciones = n_generaciones,
                    tipo_seleccion = tipo_seleccion,
                    metodo_cruce = metodo_cruce,
                    p_sobrevivientes = p_sobrevivientes,
                    probabilidad_mutacion = probabilidad_mutacion,
                    parada_temprana = parada_temprana,
                    rondas_parada = rondas_parada,
                    tolerancia_parada = tolerancia_parada,
                    verbose = verbose,
                    verbose_evaluacion = verbose_evaluacion
                   )
# %% [markdown]
"""##Evolucion del mejor Individuo en Ruleta"""
# %% 
# Evolución de la optimización
plt.style.use('ggplot')
fig, ax = plt.subplots(figsize=(7, 4))
poblacion.resultados_df.plot(x = "generacion",
                             y = "mejor_puntaje_real",
                             ax= ax)
ax.set(title='Evolución del mejor Individuo', xlabel='generacion', ylabel='fitness')
ax.legend().set_visible(False)
# %% [markdown]
"""##Evolucion de la presión de selección en Ruleta"""
# %% 
plt.style.use('ggplot')
plt.xlabel("Generacion")
plt.ylabel("Presiones")
plt.plot(np.arange(len(poblacion.presion_de_seleccion)),poblacion.presion_de_seleccion)
plt.savefig('../log_image.png')
plt.show()